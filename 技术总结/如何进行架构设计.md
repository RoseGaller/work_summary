架构设计的主要目标，是要能低成本地满足需求和需求变化，低成本地保障软件运行

# 什么是架构

系统与子系统

系统泛指由一群有关联的个体组成，根据某种规则运作，能完成个别元件不能单独完成的工作的群体

子系统也是由一群有关联的个体所组成的系统，多半会是更大系统中的一部分

其实子系统的定义和系统定义是一样的，只是观察的角度有差异，一个系统可能是另外一个更大系统的子系统。

模块与组件

模块和组件都是系统的组成部分，只是从不同的角度拆分系统而已

从逻辑的角度来拆分系统后，得到的单元就是“模块”，分模块的主要目的是职责分离

从物理的角度来拆分系统后，得到的单元就是“组件”，划分组件的主要目的是单元复用

以一个学生信息管理系统来说，这个系统从逻辑的角度来拆分，可以分为“登录注册模块”“个人信息模块”“个人成绩模块”；从物理的角度来拆分，可以拆分为 Nginx、Web 服务器、MySQL

框架与架构

软件框架（Software framework）通常指的是为了实现某个业界标准或完成特定基本任务的**软件组件规范**，也指为了实现某个软件组件规范时，提供规范所要求之基础功能的**软件产品**。

软件架构指软件系统的“基础结构”，创造这些基础结构的准则，以及对这些结构的描述。

框架关注的是规范，架构关注的是结构

重新定义架构

软件架构指软件系统的顶层结构

首先，“系统是一群关联个体组成”，这些“个体”可以是“子系统”“模块”“组件”等；架构需要明确系统包含哪些“个体“

其次，系统中的个体需要“根据某种规则”运作，架构需要明确个体运作和协作的规则

## 4R架构

软件架构指软件系统的顶层结构（Rank），它定义了系统由哪些角色（Role）组成，角色之间的关系（Relation）和运作规则（Rule）

架构是分层的，系统含有哪些角色，角色之间的关系，角色之间如何协作完成系统的功能

## 架构师职责

1、确定层级

2、拆解角色

3.、定义关系

4、设计规则

## 架构文档内容

1、指明层级

2、描述角色

3、定义关系

4、展现规则

## 如何学习架构

1、自顶向下学习

2、角色有哪些

3、角色关系如何？

4、运作规则是什么

# 架构分类

## 按业务划分

业务架构图

描述系统对用户提供了什么业务功能

## 按领域划分

### 客户端

按模块划分

​	客户端架构

### 前端

按模块划分

​	前端架构

### 后端

#### 按模块划分

​	系统/后端架构

​	后端的逻辑架构，又叫“后端架构”，“技术架构”

#### 按应用划分

​	应用架构

​	描述后端系统由哪些应用组成，应用架构是系统架构的下一层实现

#### 按组件划分

部署架构

​	描述后端系统具体如何部署的



# 面向复杂度的架构设计

## 本质

架构的本质就是降低软件系统的复杂度

## 思路

通过分析系统需求找到系统复杂的地方，然后设计方案

## 模式

复杂度来源，高性能、高可用、可扩展、安全、成本

## 套路

分库分表、缓存、集群、分片、微服务、异地多活

## 设计环

1、分析产品需求、对于不确定需求需要澄清、理解需求（价值点、要求点、功能点）

2、判断复杂度有哪些（高性能、高可用、可扩展、成本/安全）

将主要的复杂度问题列出来，然后根据业务、技术、团队等综合情况进行排序，优先解决当前面临的最主要的复杂度问题

3、思考用什么方式拆解系统，降低复杂度（拆解出role）

4、拆解后会得到多个备选架构，然后进行取舍 （团队的技术水平、方案的成本、开发周期、对方的认可度）

选择哪种方法来评估和选择备选方案？

360 度环评，具体的操作方式为：列出我们需要关注的质量属性点，然后分别从这些质量属性的维度去评估每个方案，再综合挑选适合当时情况的最优方案

常见的方案质量属性点有：性能、可用性、硬件成本、项目投入、复杂度、安全性、可扩展性等

在评估这些质量属性时，需要遵循架构设计原则 1“合适原则”和原则 2“简单原则”，避免贪大求全，基本上某个质量属性能够满足一定时期内业务发展就可以了

完成方案的 360 度环评后，我们可以基于评估结果整理出 360 度环评表，一目了然地看到各个方案的优劣点

最后综合当前的业务发展情况、团队人员规模和技能、业务发展预测等因素，将质量属性按照优先级排序，首先挑选满足第一优先级的，如果方案都满足，那就再看第二优先级......以此类推

5、选定架构方案后，进行细化

# 架构设计原则

## 架构设计三原则

### 架构设计原则1 – 合适原则

合适原则宣言：“合适优于业界领先”！

资源约束、时间积累、业务背景

设计出来的架构要满足当时的业务需要，符合团队和技术的能力水平

### 架构设计原则2 – 简单原则

简单原则宣言：“简单优于复杂”

先按照简单的方式来设计架构，然后不断地在实际应用过程中迭代优化

### 架构设计原则3 – 演化原则

演化原则宣言：“演化优于一步到位”

软件可变性、环境可变性

当业务发生变化时，架构要扩展、重构，甚至重写

## 设计原则常见的判断维度

### 业务

1. 业务当前的量级

2. 业务发展速度

3. 业务的发展形态

### 团队

1. 团队规模

2. 团队能力水平

3. 投入的资源

### 技术

1. 已有技术体系

2. 当前技术能力

3. 技术成熟度



# 高性能架构设计

## 单机高性能

### 计算高性能

#### 进程模型

多进程

多线程

#### 网络模型

TPC/PPC

Reactor

#### 缓存模型

本地缓存

独立缓存

### 存储高性能

#### 存储模型

B+tree

LSM

## 集群高性能

### 概要

计算和存储的高性能都通过任务分配和任务分解实现

### 任务分配

【任务分配】

**将任务分配给多个服务器执行**

【复杂度分析】

1）增加“任务分配器”节点，可以是独立的服务器，也可以是SDK
2）任务分配器需要管理所有的服务器，可以通过配置文件，也可以通过配置服务器（例如ZooKeeper）
3）任务分配器需要根据不同的需求采用不同的算法分配

#### 设计核心

##### 运行形态

SDK、独立的服务器

##### 配置获取

本地配置文件、远端的配置中心

##### 分配算法

随机/轮询/权重/Hash/负载

#### 样例

Nginx架构模式，服务器级别的“任务分配”，类似还有F5、LVS

1）独立服务器
2）配置文件
3）负载均衡算法

Memcache架构模式，系统内部的“任务分配”，类似还有RedisCluster

1）SDK
2）代码配置
3）一致性hash

### 任务分解

【任务分解】
**将服务器拆分为不同角色，不同服务器处理不同的业务**
【复杂度分析】
1）增加“任务分解器”节点，可以是独立的服务器，也可以是SDK
2）任务分解器需要管理所有的服务器，可以通过配置文件，也可以通过配置服务器（例如ZooKeeper）
3）**需要设计任务拆分的方式，任务分解器需要记录“任务”和“服务器”的映射关系**
4）任务分解器需要根据不同的需求采用不同的算法分配

#### 设计核心

##### 任务拆分

任务分类，例如读写分离

任务分段，例如数据库分表

##### 运行形态

SDK

服务器

##### 配置获取

配置文件

配置中心

##### 分配算法

随机、轮询、权重

Hash、负载

路由、Sharding

上述算法可能需要组合运用

将服务器拆分为不同角色，不同服务器处理不同的业务

# 可扩展架构设计

## 概念

**可扩展定义：系统适应变化的能力，包含可理解和可复用两个部分**

**可伸缩定义：系统通过添加更多资源来提升性能的能力**

## 分层

架构可扩展

应用可扩展

代码可扩展

## 手段

### 拆分

#### 拆分形态

服务

模块

插件

package

#### 拆分粒度

内部复杂度

指单个对象内部的复杂度，例如传统的单体系统，所以业务都在一个系统里面。可以用参与的开发人数来衡量单个拆分对象的复杂度

外部复杂度

指拆分后的多个对象之间的关系复杂度

可以用业务流程涉及对象数量来衡量外部复杂度

#### 原则

内外平衡原则

​	内部复杂度和外部复杂度是天平的两端，一方降低，另一方必然升高，关键在于平衡

先粗后细原则

​	如果你把握不准，那么就先拆少一些，后面发现有问题再继续拆分

### 封装（可复用）

#### 预测变化

2年法则：只预测2年内的可能变化，不要试图预测10年后的变化

3次法则：预测没有把握就不要封装，等到需要的时候重构即可

#### 封装变化

规则引擎

微内核

抽象层

设计模式

# 高可用架构设计

## 核心理念

​	冗余法则，高可用方案必然是“集群”方案！

## 计算高可用

### 任务分配

**状态检测**

运行形态

配置获取

分配算法

### 任务分解

任务拆分

任务分解器需要记录“任务”和“服务器”的映射关系

**状态检测**

运行形态

配置获取

分配算法

## 存储高可用

### 数据复制

#### 复制格式

复制命令

​	简单、数据量小

​	数据可能不一致

复制数据

​	简单，复制数据量大

​	数据一致

复制文件

​	实现复杂，复制数据量大

​	数据一致

#### 复制方式

同步复制

异步复制

半同步复制

​	同步复制和异步复制的折中方案

多数复制

​	一致性强，可用性高,实现复杂，性能低

### 状态决策

#### 独裁

决策简单

决策者本身的高可用复杂

#### 协商

架构简单，决策简单

双主问题，用双通道解决

#### 民主

架构复杂，决策复杂

脑裂问题，用quorum解决

可用性最高

# 全面提升架构设计质量

## 成本

低成本本质上是对架构的一种约束，与高性能等架构是冲突的

优化和创新降低成本

先设计架构方案，再看如何降低成本

UNIX哲学之经济原则：宁花机器一分，不花程序员一秒！

## 安全

### 架构安全

网络隔离

防火墙

流量清洗

运营商服务

机房切换

多机房

### 业务安全

业务漏洞

保底限制

安全漏洞

安全框架

内鬼破坏

权限控制

## 可测试性

### 架构可测试

全链路压测

手动触发系统行为

### 应用可测试

变量可修改

状态可见

行为可触发

## 可维护性

### 架构可维护

全链路跟踪

提供各种维护手段

降级

下线

切换

### 应用可维护

变量可修改

状态可见

行为可触发

## 可观测行

### 信息输出

日志

API

命令行

### 信息展现

运维平台

管理平台

## 如何设计更好的架构

需求 ->复杂度 ->备选架构 ->总体架构 ->成本、安全、可测试性、可维护性、可观测性  ->架构方案

# 接口高可用设计

## 分类

### 应对请求太多

限流

排队

### 应对接口故障

熔断

降级

## 限流

### 分类

请求端限流

接入端限流

服务端限流

### 算法

固定时间窗

滑动时间窗

漏桶

​	总量控制

令牌桶

​	速率控制

## 排队

本质

​	请求缓存

​	同步改异步

​	请求端轮询

## 降级

停用接口或服务

降级非核心业务

## 熔断

一段时间内不再访问有故障的接口

框架或者SDK实现

# 微服务拆分

## 微服务拆分粒度

根据“三个火枪手”原则，即一个微服务三个人负责开发

“三个火枪手”的原则主要应用于微服务设计和开发阶段

如果微服务经过一段时间发展后已经比较稳定，处于维护期了，无须太多的开发，那么平均 1 个人维护 1 个微服务甚至几个微服务都可以

当然考虑到人员备份问题，每个微服务最好都安排 2 个人维护

## 基于业务逻辑拆分

将系统中的业务模块按照职责范围识别出来，每个单独的业务模块拆分为一个独立的服务

## 基于可扩展拆分

将系统中的业务模块按照稳定性排序，将已经成熟和改动不大的服务拆分为稳定服务

将经常变化和迭代的服务拆分为变动服务

稳定的服务粒度可以粗一些，即使逻辑上没有强关联的服务，也可以放在同一个子系统中
这样拆分主要是为了提升项目快速迭代的效率，避免在开发的时候，不小心影响了已有的成熟功能导致线上问题

## 基于可靠性拆分

将系统中的业务模块按照优先级排序，将可靠性要求高的核心服务和可靠性要求低的非核心服务拆分开来，然后重点保证核心服务的高可用

具体拆分的时候，核心服务可以是一个也可以是多个，只要最终的服务数量满足“三个火枪手”的原则就可以

避免非核心服务故障影响核心服务,核心服务高可用方案可以更简单,能够降低高可用成本

## 基于性能拆分

将性能要求高或者性能压力大的模块拆分出来，避免性能压力大的服务影响其他服务

常见的拆分方式和具体的性能瓶颈有关，可以拆分 Web服务、数据库、缓存等

以上几种拆分方式不是多选一，而是可以根据实际情况自由排列组合

# 负载均衡设计

## 级联负载均衡架构

### 分级

一级：DNS

二级：F5/LVS

三级：Nginx

四级：服务路由

### 设计核心

性能

可维护性

## DNS

地理位置和机房级别的负载均衡

能力有限，不够灵活，DNS劫持，DNS缓存

HTTP-DNS

应用：app、客户端

不太适合web业务

## GSLB

应用：超大规模业务，多地部署

## F5

功能强大，性能强悍

硬件实现

成本高

L4负载均衡

性能量级：100万~1000万

## LVS

功能简单，性能较强

Linux内核实现

成本一般

L4负载均衡

性能量级：10万~100万

## Nginx

成本低

L7层Http负载均衡

性能量级：5万~10万

## 负载均衡技巧

### 通用算法

轮询

加权轮询

随机

负载优先

性能优先

hash

### 业务负载均衡技巧

Cookie

自定义HttpHeader

url query string

### 服务性能估算

#### 接口性能

1、线上业务服务器接口处理时间分布为20~100ms

2、平均大约为50ms

3、访问存储或者其他系统接口是主要的性能消耗点

#### 服务器性能

线上单个服务器（32核）性能大约为300~1000TPS/QPS

负载均衡架构

# 多级缓存设计

## 概念

### 缓存

定义：协调性能差异的结构，存放读数据

本质：空间换时间

分类：高性能计算架构

### 缓冲

定义：暂存需要传输数据的的结构，存放写数据

## 缓存设计

缓存内容

缓存时间

缓存系统

### 更新机制

过期更新

定期更新

主动更新

不更新

## 多级缓存

本地缓存

​	App缓存

​	HTTP缓存

CDN缓存

​	就近访问

​	边缘服务器

​	功能强大

​	贵

Web容器缓存

​	静态资源

​	配合HTTP

应用缓存

​	进程内

​	进程外

​	本地SSD磁盘

分布式缓存

​	Redis

​	Memcached







架构的本质就是：
通过合理的内部编排，保证系统高度有序，能够不断扩展，满足业务和技术的变化

首先，架构的出发点是业务和技术在不断复杂化，引起系统混乱，需要通过架构来保证有
序

其次，架构实现从无序到有序，是通过合理的内部编排实现的，基本的手段，就是“分”与“合”，先把系统打散，然后将它们重新组合，形成更合理的关系。

“分”就是把系统拆分为各个子系统、模块、组件。拆分的时候，首先要解决每个部分的定位问题，然后根据定位，划分彼此的边界，最后实现合理的拆分，我们比较熟悉的微服务架构，就是一种典型的拆分做法。
“合”就是基于业务流程和技术手段，把各个组件有机整合在一起。比如说在微服务架构中，拆分为具体微服务后，我们需要对这些服务进行归类和分层，有些属于底层基础服务，有些属于上层聚合服务，还要尽可能地实现服务的平台化，比如我们最近说的中台，这些都是合的思想体现。



业务架构就是讲清楚核心业务的处理过程，定义各个业务模块的相互关系，它从
概念层面帮助我们理解系统面临哪些问题以及如何处理；

而应用架构就是讲清楚系统内部是怎么组织的，有哪些应用，相互间是怎么调用的，它从逻辑层面帮助我们理解系统内部是如何分工与协作的

技术架构就是讲清楚系统由哪些硬件、操作系统和中间件组成，它们是如何和我们开发的应
用一起配合，应对各种异常情况，保持系统的稳定可用。所以，技术架构从物理层面帮助我
们理解系统是如何构造的，以及如何解决稳定性的问题

做架构设计时，一般是先考虑业务架构，再应用架构，最后是技术架构

一个好的架构设计既要满足业务的可扩展、可复用；也要满足系统的高可用、高性能
和可伸缩，并尽量采用低成本的方式落地。所以，对架构设计来说，技术和业务两手都要
抓，两手都要硬



对业务架构师来说，TA 的工作，就是梳理业务流程，并把其中的节点打散，按照业务域的维度来划分系统模块，并定义这些模块之间的关系，最终形成一个高度结构化的模块体系





要做架构升级，主要是要分析在预估的QPS下，整个系统的瓶颈会在什么地方，要针对这起瓶颈来重新设计架构方案







什么是架构设计？

可以分别从目标和方法两个角度来看

架构设计的目标，是用最小的人力成本来满足需求的开发和响应需求的变化，用最小的运行成本来保障软件的运行。

架构设计，已经有很多成熟的方法。比如说：
使用微服务这样的架构，把复杂系统拆分成一系列小的服务，服务再拆成功能模块，让人员更好地分工协作；
通过前后端分离，让程序员更专注于某个知识领域，降低开发难度；
用分层设计来隔离业务逻辑，减少需求变更带来的影响。

架构设计的道，就是把系统和团队拆分，并安排好切分后的排列关系，让拆分后的部分能通过约定好的协议相互通信，共同实现最终的结果

如何做好架构设计？

第一步：分析需求

架构设计，最基本的就是要能满足业务需求，所以搞清楚需求是至关重要一步。而产品需求，只有功能的描述，界面的交互，还需要进一步进行抽象

常用的分析方法就是分析用例，也就是了解主要用户角色和其使用的场景。

第二步：选择相似的成熟的架构设计方案

在了解清楚需求后，就可以从业界成熟的架构设计模式中选取一个或几个。当然，具体选择哪些架构设计模式，需要你根据平时的学习积累来做判断。到这个阶段，同时还要考虑使用的语言和框架

典型的网站架构，可以基于传统的分层架构来实现。分层架构按照水平方向将系统拆分成几个层，每层都有清晰的角色和分工，不需要关心其他层的细节

第三步：自顶向下层层细化

部署架构

分层架构网站，部署也比较简单。为了减少运维成本，我们可以基于云服务设计部署架构，选购云数据库和文件存储，选购虚机作为网站服务器。

分层和分模块

用户界面层：用户界面，负责展现功能以及和用户交互。
服务层：API 服务和 Web 网站服务。
业务逻辑层：实现业务逻辑，比如说如何读取用户订阅的专栏列表。
数据访问层：对数据库的访问。
数据存储：用数据库保存数据，文件库保存音频文件。

分层分好后，还需要基于前面的用例图，把相同的功能抽象出来，设计成模块

在分层和分模块之后，就可以很好的对人员进行分工，可以把具体工作细分到某一层的某个模块

API 设计、数据库设计、模块的设计

在分层和分模块的设计完成后，就可以对 API 进行设计，对数据库进行表设计

第四步：验证和优化架构设计方案

在技术方案完成后，还需要去验证方案是不是满足设计的目标，能否满足需求和未来需求的变化，能否保障软件有效地运行。



一个完整的架构设计方案，需要有多次的评审会议，充分收集各方面的反馈，反复修改后才能最终确定下来

在第二、三步，可能会生成几个技术方案，这时候就需要做出一些技术上的决策。决策时，需要考虑清楚方案是否能低成本的完成软件需求的开发，同时能低成本的运行和维护该软件。还有你要考虑架构预期要满足多长时间的业务增长

在架构设计确定后，就可以基于架构设计的结果大家一起分工协作了。

架构设计并不是确定后就不修改了，在实际开发的过程中，还需要根据情况对架构进行优化和调整。



如何进行技术选型

中间件提供的功能特性

注意中间件的性能和扩展性

中间件的编程语言
