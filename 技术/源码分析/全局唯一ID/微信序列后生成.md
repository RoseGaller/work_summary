**微信服务器端为每一份需要与客户端同步的数据（例如消息）都会赋予一个唯一的、递增的序列号（后文称为sequence），作为这份数据的版本号**



用作数据版本号的sequence，具有两种基本的性质：

> 1. 全局递增的64位整型变量
> 2. 每个用户都有自己独立的64位sequence空间

微信使用了每个用户独立的64位sequence的体系，而不是用一个全局的64位（或更高位）sequence，很大原因是全局唯一的sequence会有非常严重的申请互斥问题，不容易去实现一个高性能高可靠的架构

1、不考虑架构设计

不考虑seqsvr的具体架构的话，它应该是一个巨大的64位数组，而我们每一个微信用户，都在这个大数组里独占一格8bytes的空间，这个格子就放着用户已经分配出去的最后一个sequence：cur_seq。每个用户来申请sequence的时候，只需要将用户的cur_seq+=1，保存回数组（存储到磁盘，每次申请都会都存储，增加磁盘压力），并返回给用户

2、号段模式减轻磁盘压力

sequence只要求递增，并没有要求连续，也就是说出现一大段跳跃是允许的

1. 内存中储存最近一个分配出去的sequence：cur_seq，以及分配上限：max_seq
2. 分配sequence时，将cur_seq++，同时与分配上限max_seq比较：如果cur_seq > max_seq，将分配上限提升一个步长max_seq += step，并持久化max_seq
3. 重启时，读出持久化的max_seq，赋值给cur_seq

3、分号段共享存储

上述模式的问题：重启时要读取大量的max_seq数据加载到内存中