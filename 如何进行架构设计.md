# 什么是架构

## 4R架构

软件架构指软件系统的顶层结构（Rank），它定义了系统由哪些角色（Role）组成，角色之间的关系（Relation）和运作规则（Rule）

架构是分层的，系统含有哪些角色，角色之间的关系，角色之间如何协作完成系统的功能

## 架构师职责

1、确定层级

2、拆解角色

3.、定义关系

4、设计规则

## 架构文档内容

1、指明层级

2、描述角色

3、定义关系

4、展现规则

## 如何学习架构

1、自顶向下学习

2、角色有哪些

3、角色关系如何？

4、运作规则是什么

# 架构分类

## 按业务划分

业务架构图

描述系统对用户提供了什么业务功能

## 按领域划分

### 客户端

按模块划分

​	客户端架构

### 前端

按模块划分

​	前端架构

### 后端

#### 按模块划分

​	系统/后端架构

​	后端的逻辑架构，又叫“后端架构”，“技术架构”

#### 按应用划分

​	应用架构

​	描述后端系统由哪些应用组成，应用架构是系统架构的下一层实现

#### 按组件划分

部署架构

​	描述后端系统具体如何部署的



# 面向复杂度的架构设计

## 本质

架构的本质就是降低软件系统的复杂度

## 思路

通过分析系统需求找到系统复杂的地方，然后设计方案

## 模式

复杂度来源，高性能、高可用、可扩展、安全、成本

## 套路

分库分表、缓存、集群、分片、微服务、异地多活

## 设计环

1、分析产品需求、对于不确定需求需要澄清、理解需求（价值点、要求点、功能点）

2、判断复杂度有哪些（高性能、高可用、可扩展、成本/安全），复杂度是否符合设计原则

3、思考用什么方式拆解系统，降低复杂度（拆解出role）

4、拆解后会得到多个备选架构，然后进行取舍 （团队的技术水平、方案的成本、开发周期、对方的认可度）

5、选定架构方案后，进行细化

# 架构设计原则

## 架构设计三原则

### 架构设计原则1 – 合适原则

合适原则宣言：“合适优于业界领先”！

资源约束、时间积累、业务背景

设计出来的架构要满足当时的业务需要，符合团队和技术的能力水平

### 架构设计原则2 – 简单原则

简单原则宣言：“简单优于复杂”

先按照简单的方式来设计架构，然后不断地在实际应用过程中迭代优化

### 架构设计原则3 – 演化原则

演化原则宣言：“演化优于一步到位”

软件可变性、环境可变性

当业务发生变化时，架构要扩展、重构，甚至重写

## 设计原则常见的判断维度

### 业务

1. 业务当前的量级

2. 业务发展速度

3. 业务的发展形态

### 团队

1. 团队规模

2. 团队能力水平

3. 投入的资源

### 技术

1. 已有技术体系

2. 当前技术能力

3. 技术成熟度



# 高性能架构设计

## 单机高性能

### 计算高性能

#### 进程模型

多进程

多线程

#### 网络模型

TPC/PPC

Reactor

#### 缓存模型

本地缓存

独立缓存

### 存储高性能

#### 存储模型

B+tree

LSM

## 集群高性能

### 概要

计算和存储的高性能都通过任务分配和任务分解实现

### 任务分配

【任务分配】

**将任务分配给多个服务器执行**

【复杂度分析】

1）增加“任务分配器”节点，可以是独立的服务器，也可以是SDK
2）任务分配器需要管理所有的服务器，可以通过配置文件，也可以通过配置服务器（例如ZooKeeper）
3）任务分配器需要根据不同的需求采用不同的算法分配

#### 设计核心

##### 运行形态

SDK、独立的服务器

##### 配置获取

本地配置文件、远端的配置中心

##### 分配算法

随机/轮询/权重/Hash/负载

#### 样例

Nginx架构模式，服务器级别的“任务分配”，类似还有F5、LVS

1）独立服务器
2）配置文件
3）负载均衡算法

Memcache架构模式，系统内部的“任务分配”，类似还有RedisCluster

1）SDK
2）代码配置
3）一致性hash

### 任务分解

【任务分解】
**将服务器拆分为不同角色，不同服务器处理不同的业务**
【复杂度分析】
1）增加“任务分解器”节点，可以是独立的服务器，也可以是SDK
2）任务分解器需要管理所有的服务器，可以通过配置文件，也可以通过配置服务器（例如ZooKeeper）
3）**需要设计任务拆分的方式，任务分解器需要记录“任务”和“服务器”的映射关系**
4）任务分解器需要根据不同的需求采用不同的算法分配

#### 设计核心

##### 任务拆分

任务分类，例如读写分离

任务分段，例如数据库分表

##### 运行形态

SDK

服务器

##### 配置获取

配置文件

配置中心

##### 分配算法

随机、轮询、权重

Hash、负载

路由、Sharding

上述算法可能需要组合运用

将服务器拆分为不同角色，不同服务器处理不同的业务

# 可扩展架构设计

## 概念

**可扩展定义：系统适应变化的能力，包含可理解和可复用两个部分**

**可伸缩定义：系统通过添加更多资源来提升性能的能力**

## 分层

架构可扩展

应用可扩展

代码可扩展

## 手段

### 拆分

#### 拆分形态

服务

模块

插件

package

#### 拆分粒度

内部复杂度

指单个对象内部的复杂度，例如传统的单体系统，所以业务都在一个系统里面。可以用参与的开发人数来衡量单个拆分对象的复杂度

外部复杂度

指拆分后的多个对象之间的关系复杂度

可以用业务流程涉及对象数量来衡量外部复杂度

#### 原则

内外平衡原则

​	内部复杂度和外部复杂度是天平的两端，一方降低，另一方必然升高，关键在于平衡

先粗后细原则

​	如果你把握不准，那么就先拆少一些，后面发现有问题再继续拆分

### 封装（可复用）

#### 预测变化

2年法则：只预测2年内的可能变化，不要试图预测10年后的变化

3次法则：预测没有把握就不要封装，等到需要的时候重构即可

#### 封装变化

规则引擎

微内核

抽象层

设计模式

# 高可用架构设计

## 核心理念

​	冗余法则，高可用方案必然是“集群”方案！

## 计算高可用

### 任务分配

**状态检测**

运行形态

配置获取

分配算法

### 任务分解

任务拆分

任务分解器需要记录“任务”和“服务器”的映射关系

**状态检测**

运行形态

配置获取

分配算法

## 存储高可用

### 数据复制

#### 复制格式

复制命令

​	简单、数据量小

​	数据可能不一致

复制数据

​	简单，复制数据量大

​	数据一致

复制文件

​	实现复杂，复制数据量大

​	数据一致

#### 复制方式

同步复制

异步复制

半同步复制

​	同步复制和异步复制的折中方案

多数复制

​	一致性强，可用性高,实现复杂，性能低

### 状态决策

#### 独裁

决策简单

决策者本身的高可用复杂

#### 协商

架构简单，决策简单

双主问题，用双通道解决

#### 民主

架构复杂，决策复杂

脑裂问题，用quorum解决

可用性最高

# 全面提升架构设计质量

## 成本

低成本本质上是对架构的一种约束，与高性能等架构是冲突的

优化和创新降低成本

先设计架构方案，再看如何降低成本

UNIX哲学之经济原则：宁花机器一分，不花程序员一秒！

## 安全

### 架构安全

网络隔离

防火墙

流量清洗

运营商服务

机房切换

多机房

### 业务安全

业务漏洞

保底限制

安全漏洞

安全框架

内鬼破坏

权限控制

## 可测试性

### 架构可测试

全链路压测

手动触发系统行为

### 应用可测试

变量可修改

状态可见

行为可触发

## 可维护性

### 架构可维护

全链路跟踪

提供各种维护手段

降级

下线

切换

### 应用可维护

变量可修改

状态可见

行为可触发

## 可观测行

### 信息输出

日志

API

命令行

### 信息展现

运维平台

管理平台

## 如何设计更好的架构

需求 ->复杂度 ->备选架构 ->总体架构 ->成本、安全、可测试性、可维护性、可观测性  ->架构方案

# 接口高可用设计

## 分类

### 应对请求太多

限流

排队

### 应对接口故障

熔断

降级

## 限流

### 分类

请求端限流

接入端限流

服务端限流

### 算法

固定时间窗

滑动时间窗

漏桶

​	总量控制

令牌桶

​	速率控制

## 排队

本质

​	请求缓存

​	同步改异步

​	请求端轮询

## 降级

停用接口或服务

降级非核心业务

## 熔断

一段时间内不再访问有故障的接口

框架或者SDK实现

# 微服务拆分

## 按业务拆分

DDD不适合落地*

### 业务边界划分

业务专家

粗分然后演进

参考已有实现

### 服务拆分

三个火枪手

领域1对1

领域多对1

领域1对多

## 按质量拆分

按性能拆分

按业务重要程度拆分

按可用性拆分

按稳定性拆分

# 负载均衡设计

## 级联负载均衡架构

### 分级

一级：DNS

二级：F5/LVS

三级：Nginx

四级：服务路由

### 设计核心

性能

可维护性

## DNS

地理位置和机房级别的负载均衡

能力有限，不够灵活，DNS劫持，DNS缓存

HTTP-DNS

应用：app、客户端

不太适合web业务

## GSLB

应用：超大规模业务，多地部署

## F5

功能强大，性能强悍

硬件实现

成本高

L4负载均衡

性能量级：100万~1000万

## LVS

功能简单，性能较强

Linux内核实现

成本一般

L4负载均衡

性能量级：10万~100万

## Nginx

成本低

L7层Http负载均衡

性能量级：5万~10万

## 负载均衡技巧

### 通用算法

轮询

加权轮询

随机

负载优先

性能优先

hash

### 业务负载均衡技巧

Cookie

自定义HttpHeader

url query string

### 服务性能估算

#### 接口性能

1、线上业务服务器接口处理时间分布为20~100ms

2、平均大约为50ms

3、访问存储或者其他系统接口是主要的性能消耗点

#### 服务器性能

线上单个服务器（32核）性能大约为300~1000TPS/QPS

负载均衡架构

# 多级缓存设计

## 概念

### 缓存

定义：协调性能差异的结构，存放读数据

本质：空间换时间

分类：高性能计算架构

### 缓冲

定义：暂存需要传输数据的的结构，存放写数据

## 缓存设计

缓存内容

缓存时间

缓存系统

### 更新机制

过期更新

定期更新

主动更新

不更新

## 多级缓存

本地缓存

​	App缓存

​	HTTP缓存

CDN缓存

​	就近访问

​	边缘服务器

​	功能强大

​	贵

Web容器缓存

​	静态资源

​	配合HTTP

应用缓存

​	进程内

​	进程外

​	本地SSD磁盘

分布式缓存

​	Redis

​	Memcached















