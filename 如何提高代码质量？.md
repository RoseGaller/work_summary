# 代码坏味道

## 如何避免命名的坏味道

​		好的名字应该描述意图，而非细节

​		避免用技术术语命名

```java
List<Book> bookList = service.getBooks(); //坏味道，一种基于实现细节的命名方式
List<Book> books = service.getBooks(); //好味道
```

​		编写可维护的代码要使用业务语言，建立团队的词汇表

## 如何避免乱用英文？

​		制定代码规范，比如，类名要用名词，函数名要用动词或动宾短语

​		建立团队的词汇表

​		要经常进行代码评审

## 如何避免重复？

​		避免复制粘贴，提取一个新的函数出来，把公共的部分先统一掉

​		识别结构重复的代码、识别if 和 else 代码块中高度类似的语句

## 如何避免长函数？

​		定义好函数长度的标准

```xml
<!--CheckStyle 的配置文件-->
<module name="MethodLength">
	<property name="tokens" value="METHOD_DEF"/>
	<property name="max" value="20"/>
	<property name="countEmpty" value="false"/>
</module>
```

​		做好分离关注点，避免多业务、多层次的代码写到一起

## 如何避免大类？

职责不单一、字段未分组

​		把不同的职责拆分开来

​		将不稳定的字段进行抽离

把类写小，越小越好。

## 如何避免长参数？

参数数量过多导致的长参数

​		把长参数列表封装成一个类，这能解决大部分的长参数列表（参数都属于一个类，有相同的变化原因）

​		对于静态不变的参数，可以成为软件结构的一部分（依赖注入），而不是当做参数传递

标记参数导致的长函数

​		根据标记参数，将函数拆分为多个函数

## 如何避免滥用控制语句？

嵌套的代码

​	将循环中的内容封装成函数

else语句

​		以卫语句取代嵌套的条件表达式是一种改善嵌套代码的优化代码

​		也就是设置单独的检查条件，不满足这个检查条件时，立刻从函数中返回

重复的switch

​	多态取代条件表达式

编程规则：函数至多有一层缩进;不要使用 else 关键字

## 如何应对散乱的代码？

过长的消息链

```java
//一行代码中有连续多个方法调用,种坏味道起的名字叫过长的消息链（MessageChains）,
//也称火车残骸（Train Wreck）
String name = book.getAuthor().getName();  //坏味道
```

```java
class Book {
...
public String getAuthorName() { //隐藏委托关系，把多个方法调用封装起来
return this.author.getName();
}
...
}
String name = book.getAuthorName();
//做好封装，要先从少暴露细节开始
```

迪米特法则（Law of Demeter）

​	每个单元对其它单元只拥有有限的知识，而且这些单元是与当前单元有紧密联系的

​	每个单元只能与其朋友交谈，不与陌生人交谈

​	只与自己最直接的朋友交谈

基本类型偏执

引入一个模型封装基本类型的重构手法，叫做以对象取代基本类型（ReplacePrimitive with Object）

```java
class Price {
  private double price; //对double基本类型封装
  public Price(final double price) {
  if (price <= 0) {
  throw new IllegalArgumentException("Price should be positive");
  }
  this.price = price;
  }
}
//构建模型，封装散落的代码
```



## 如何让可变的数据变得可控？

满天飞的 Setter

​		setter 往往是缺乏封装的一种做法,相比于读数据，修改是一个更危险的操作

​		避免随处调用setter，用一个函数替代 setter，把它用行为封装了起来，将变化变得可控

​		消除 setter ，有一种专门的重构手法，叫做移除设值函数（Remove SettingMethod）。总而言之，setter 是完全没有必要存在的

```properties
#lombok.config配置文件
#禁用 @Setter，禁用 @Data 
lombok.setter.flagUsage = error
lombok.data.flagUsage = error
```

解决可变数据，还有一个解决方案是编写不变类

​	所有的字段只在构造函数中初始化

​	所有的方法都是纯函数

​	如果需要有改变，返回一个新的对象，而不是修改已有字段

## 如何避免变量的声明与赋值分离？

变量一次性完成初始化

```java
InputStream is = null; //坏味道
try {
is = new FileInputStream(...);
...
} catch (IOException e) {
...
} finally {
if (is != null) {
is.close();
}
}
```

```java
try (InputStream is = new FileInputStream(...)) {//好味道
...
}
```

尽可能使用不变的量

在能够使用 final 的地方尽量使用 final

用声明式的方式进行集合的初始化

```java
//命令式
List<Permission> permissions = new ArrayList<>();
permissions.add(Permission.BOOK_READ);
permissions.add(Permission.BOOK_WRITE);
check.grantTo(Role.AUTHOR, permissions);
```

```java
//声明式(Java 9 之后的写法)
List<Permission> permissions = List.of(
Permission.BOOK_READ,
Permission.BOOK_WRITE
);
check.grantTo(Role.AUTHOR, permissions);
```

```java
//声明式(Guava)
List<Permission> permissions = ImmutableList.of(
Permission.BOOK_READ,
Permission.BOOK_WRITE
);
check.grantTo(Role.AUTHOR, permissions);
```

```java
//命令式的代码，就是告诉你“怎么做”的代码
//声明式的代码，是告诉你“做什么”的代码
//声明式的代码体现的意图，是更高层面的抽象，把意图和实现分开，从某种意义上来说，也是一种分离关注点
private static Map<Locale, String> CODE_MAPPING = ImmutableMap.of(
LOCALE.ENGLISH, "EN",
LOCALE.CHINESE, "CH"
);
```



## 如何解决依赖混乱？

缺少防腐层，导致不同代码糅合在一起

​		缺少防腐层，会让请求对象传导到业务代码中，造成了业务与外部接口的耦合，也就是业务依赖了一个外部通信协议

​		引入一个防腐层，将业务和接口隔离开来

```java
@Entity //表示它是一个业务实体的对象
@Table(name = "user")
//处理JSON的一个Annotation,JSON通常都是在传输中
@JsonIgnoreProperties(ignoreUnknown = true)
class User {
...
}
//业务实体和传输对象应该具备的特质在同一个类中出现，这也是没有构建好防腐层的结果，把两个职责混在了一起
```

ArchUnit

```java
//要求 Resource层的代码不能被其它层访问，而 Service 层的代码只能由 Resource 层方法访问
//一旦代码里有违反这个架构规则的代码，这个测试就会失败，问题也就会暴露出来
@Test
public void should_follow_arch_rule() {
  JavaClasses clazz = new ClassFileImporter().importPackages("...");
  ArchRule rule = layeredArchitecture()
  .layer("Resource").definedBy("..resource..")
  .layer("Service").definedBy("..service..")
  .whereLayer("Resource").mayNotBeAccessedByAnyLayer()
  .whereLayer("Service").mayOnlyBeAccessedByLayers("Resource");
  rule.check(clazz);
}
```

业务代码里出现了具体实现类

​		引入一个模型，将业务与具体的实现隔离开来

## 如何解决不一致的代码？

方案中的不一致

​		使用不同的程序库

​		必须约定，哪种做法是在项目中的标准做法，以防出现各自为战的现象。团队中使用同一的标准程序库，比如guava

命名的不一致

​		平常都会把业务写到服务层，各种服务的命名也通常都是 XXXService

​		对于那些非业务入口的业务组件，它们的名字就会不一样，会更符合其具体业务行为

代码中的不一致

​		不同层次的代码耦合在了一起

​		能够分清楚代码处于不同的层次，基本功还是分离关注点。将不同层次的内容放入不同的函数中

## 如何解决落后的代码风格？

引入Optional可以减少忽略空指针引起的问题

```java
UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
QueryWrapper<User> queryWrapper = new QueryWrapper<User>();
queryWrapper.eq("name","test666");
User user = userMapper.selectOne(queryWrapper);
//对可能为空的对象包装一层，
Optional<User> userOptional = Optional.ofNullable(user);
System.out.println(userOptional.isPresent()?userOptional.get().getName():"default");
```

函数式编程

​	循环语句本身就是一个坏味道.之所以循环语句成了坏味道，一个重要的原因就是函数式编程的兴起。不是我们不需要遍历集合，而是我们有了更好的遍历集合的方式

​	函数式编程的一个重要洞见就是，大部分操作都可以归结成列表转换，其中，最核心的列表转换就是 map、filter和reduce

​	采用列表转换写出来的代码相较于传统的循环语句写出来的代码，表达性更好，因为它们都是描述做什么，而传统的循环语句是在描述怎么做

​	自从 Java 里引入了 lambda，可以直接在列表转换过程中写 lambda。lambda 本身相当于一个匿名函数，为了防止出现长函数，可以提取出一个函数，保证 lambda只有一行代码

使用 Java 8 的时间日期类型

try-with-resource

# 代码精进之路

# 如何做需求分析和设计

## 如何做产品设计?

首先，一定不要自己一个人闷头想，我们要学会“借鉴”，可以找几个类似的产品，看看他们是如何设计的，然后借鉴到我们的产品中

除了”借鉴”的思路之外，还可以通过产品的线框图、用户用例（user case ）或者叫用户故事（user story）来细化业务流程，挖掘一些比较细节的、不容易想到的功能点

用户用例，侧重情景化，其实就是模拟用户如何使用我们的产品，描述用户在一个特定的应用场景里的一个完整的业务操作流程。所以，它包含更多的细节，且更加容易被人理解

## 如何做系统设计？

面向对象设计聚焦在代码层面（主要是针对类）

系统设计就是聚焦在架构层面（主要是针对模块）

两者有很多相似之处。很多设计原则和思想不仅仅可以应用到代码设计中，还能用到架构设计中

### 1、合理地将功能划分到不同模块

面向对象设计的本质就是把合适的代码放到合适的类中。合理地划分代码可以实现代码的高内聚、低耦合，类与类之间的交互简单清晰

系统设计实际上就是将合适的功能放到合适的模块中。合理地划分模块也可以做到模块层面的高内聚、低耦合，架构整洁清晰。

模块可以划分出多种，怎么判断哪种模块划分合理

通过看看是否符合高内聚、低耦合特性来判断，如果一个功能的修改或添加，经常要跨团队、跨项目、跨系统才能完成，那说明模块划分的不够合理，职责不够清晰，耦合过于严重

除此之外，为了避免业务知识的耦合，让下层系统更加通用，一般来讲，我们不希望下层系统（也就是被调用的系统）包含太多上层系统（也就是调用系统）的业务信息，但是，可以接受上层系统包含下层系统的业务信息

### 2、设计模块与模块之间的交互关系

在面向对象设计中，类设计好之后，我们需要设计类之间的交互关系。类比到系统设计，系统职责划分好之后，接下来就是设计系统之间的交互

比较常见的系统之间的交互方式有两种，一种是同步接口调用，另一种是利用消息中间件异步调用。第一种方式简单直接，第二种方式的解耦效果更好

### 3、设计模块的接口、数据库、业务模型

#### 接口设计

要符合单一职责原则，粒度越小通用性就越好

但是，接口粒度太小也会带来一些问题。比如，一个功能的实现要调用多个小接口，一方面如果接口调用走网络（特别是公网），多次远程接口调用会影响性能；另一方面，本该在一个接口中完成的原子操作，现在分拆成多个小接口来完成，就可能会涉及分布式事务的数据一致性问题

为了兼顾易用性和性能，我们可以借鉴facade（外观）设计模式，在职责单一的细粒度接口之上，再封装一层粗粒度的接口给外部使用

#### 业务模型的设计

从代码实现角度来说，大部分业务系统的开发都可以分为 Controller、Service、Repository 三层。Controller 层负责接口暴露，Repository 层负责数据读写，Service 层负责核心业务逻辑，也就是这里说的业务模型

现有的两种开发模式，基于贫血模型的传统开发模式和基于充血模型的DDD 开发模式

前者是一种面向过程的编程风格，后者是一种面向对象的编程风格

不管是 DDD 还是 OOP，高级开发模式的存在一般都是为了应对复杂系统，应对系统的复杂性

为什么要分 MVC 三层开发

分层能起到代码复用的作用、分层能起到隔离变化的作用、分层能起到隔离关注点的作用、分层能提高代码的可测试性、 分层能应对系统的复杂性

BO、VO、Entity 存在的意义是什么

针对 Controller、Service、Repository 三层，每层都会定义相应的数据对象，它们分别是 VO（View Object）、BO（Business Object）、Entity，例如 UserVo、UserBo、UserEntity

在实际的开发中，VO、BO、Entity 可能存在大量的重复字段，甚至三者包含的字段完全一样。在开发的过程中，我们经常需要重复定义三个几乎一样的类，显然是一种重复劳动

继承可以解决代码重复问题。我们可以将公共的字段定义在父类中，让VO、BO、Entity 都继承这个父类，各自只定义特有的字段

组合也可以解决代码重复的问题，可以将公共的字段抽取到公共的类中，VO、BO、Entity 通过组合关系来复用这个类的代码

不同分层之间的数据对象转化，比如BeanUtils、Dozer 等

## 如何根据功能需求写代码

### 1、划分职责进而识别出有哪些类

根据需求描述，把其中涉及的功能点，一个一个罗列出来，然后再去看哪些功能点职责相近，操作同样的属性，可否应该归为同一个类

### 2、定义类及其属性和方法

识别出需求描述中的动词，作为候选的方法，再进一步过滤筛选。类比一下方法的识别，我们可以把功能点中涉及的名词，作为候选属性，然后同样进行过滤筛选

### 3、定义类与类之间的交互关系

泛化（Generalization）可以简单理解为继承关系

实现（Realization）一般是指接口和实现类之间的关系

组合（Composition）也是一种包含关系。A 类对象包含 B 类对象，B 类对象的生命周期跟依赖 A 类对象的生命周期，B 类对象不可单独存在

依赖（Dependency）是一种比关联关系更加弱的关系，包含关联关系。不管是 B 类对象是 A 类对象的成员变量，还是 A 类的方法使用 B 类对象作为参数或者返回值、局部变量，只要 B 类对象和 A 类对象有任何使用关系，我们都称它们有依赖关系

### 4、 将类组装起来并提供执行入口

类定义好了，类之间必要的交互关系也设计好了，接下来我们要将所有的类组装在一起，提供一个执行入口

这个入口可能是一个 main() 函数，也可能是一组给外部用的 API 接口。通过这个入口，我们能触发整个代码跑起来

# 如何做重构

## 为什么重构？

重构是一种对软件内部结构的改善，目的是在不改变软件的可见行为的情况下，使其更易理解，修改成本更低，可以保持代码质量持续处于一个可控状态，不至于腐化到无可救药的地步

在保持功能不变的前提下，利用设计思想、原则、模式、编程规范等理论来优化代码，修改设计上的不足，提高代码质量

## 重构什么？

按照重构的规模，可以将重构大致分为大规模高层次的重构和小规模低层次的重构

大规模高层次重构包括对代码分层、模块化、解耦、梳理类之间的交互关系、抽象复用组件等等。这部分工作利用的更多的是比较抽象、比较顶层的设计思想、原则、模式。

小规模低层次的重构包括规范命名、注释、修正函数参数过多、消除超大类、提取重复代码等编程细节问题，主要是针对类、函数级别的重构。小规模低层次的重构更多的是利用编码规范这一理论知识。

## 什么时候重构？

一定要建立持续重构意识，把重构作为开发必不可少的部分融入到开发中，而不是等到代码出现很大问题的时候，再大刀阔斧地重构

## 如何重构？

大规模高层次的重构难度比较大，需要有组织、有计划地进行，分阶段地小步快跑，时刻保持代码处于一个可运行的状态

小规模低层次的重构，因为影响范围小，改动耗时短，所以，只要你愿意并且有时间，随时随地都可以去做

### 大型重构：解耦

#### “解耦”为何如此重要？

过于复杂的代码往往在可读性、可维护性上都不友好。解耦，保证代码松耦合、高内聚，是控制代码复杂度的有效手段。

#### 代码是否需要“解耦”？

间接的衡量标准有很多，比如：改动一个模块或类的代码受影响的模块或类是否有很多、改动一个模块或者类的代码依赖的模块或者类是否需要改动、代码的可测试性是否好等等

直接的衡量标准是把模块与模块之间及其类与类之间的依赖关系画出来，根据依赖关系图的复杂性来判断是否需要解耦重构

#### 如何给代码“解耦”？

1、封装与抽象

2、中间层

3、模块化

4、设计思想与原则

​	比如：单一职责原则、基于接口而非实现编程、依赖注入、多用组合少用继承、迪米特法则。

​	当然，还有一些设计模式，比如观察者模式。

### 小型重构：编码规范

#### 命名

1命名多长最合适？

在足够表达其含义的情况下，命名当然是越短越好。

对于一些默认的、大家都比较熟知的词，推荐用缩写

对于作用域比较小的变量，我们可以使用相对短的命名，比如一些函数内的临时变量。

相反，对于类名这种作用域比较大的，更推荐用长的命名方式。

2利用上下文简化命名

3命名要可读、可搜索

什么是命名可读。这里所说的“可读”，指的是不要用一些特别生僻、难发音的英文单词来命名

命名可搜索。我们在 IDE 中编写代码的时候，经常会用“关键词联想”的方法来自动补全和搜索

在命名的时候，最好能符合整个项目的命名习惯。大家都用“selectXXX”表示查询，你就不要用“queryXXX”；大家都用“insertXXX”表示插入一条数据，你就要不“addXXX”

4如何命名接口和抽象类

对于接口的命名，一般有两种比较常见的方式。一种是加前缀“I”，表示一个 Interface。比如 IUserService，对应的实现类命名为 UserService。另一种是不加前缀，比如UserService，对应的实现类加后缀“Impl”，比如 UserServiceImpl。

对于抽象类的命名，也有两种方式，一种是带上前缀“Abstract”，比如
AbstractConfiguration；另一种是不带前缀“Abstract”。实际上，对于接口和抽象类，选择哪种命名方式都是可以的，只要项目里能够统一就行

#### 注释

5注释的内容主要包含这样三个方面：做什么、为什么、怎么做。复杂的类，还要写明怎么用

函数和变量如果命名得好，确实可以不用再在注释中解释它是做什么的

6类和函数一定要写注释，而且要写得尽可能全面、详细

函数内部的注释要相对少一些，一般都是靠好的命名、提炼函数、解释性变量、总结性注释来提高代码的可读性。

#### 代码风格

7类、函数多大才合适?

对于函数代码行数的最大限制，网上有一种说法，那就是不要超过一个显示屏的垂直高度

函数的代码行数不要超过一屏幕的大小，比如 50 行。类的大小限制比较难确定。

8一行代码多长最合适？

一行代码最长不能超过 IDE 显示的宽度

需要滚动鼠标才能查看一行的全部代码，显然不利于代码的阅读

9善用空行分割单元块

对于比较长的函数，如果逻辑上可以分为几个独立的代码块，在不方便将这些独立的代码块抽取成小函数的情况下，为了让逻辑更加清晰，除了用总结性注释的方法之外，我们还可以使用空行来分割各个代码块。

10推荐使用两格缩进，这样可以节省空间，不要用tab键缩进

11大括号是否要另起一行？

比较推荐，将括号放到跟语句同一行的风格，节省代码行数

大括号跟上一条语句在同一行，还是另起新的一行，只要团队统一、业内统一、跟开源项目看齐就好了，没有绝对的优劣之分。

12类中成员的排列顺序

在 Java 类文件中，先要书写类所属的包名，然后再罗列 import 引入的依赖类

在类中，成员变量排在函数的前面。成员变量之间或函数之间，都是按照“先静态（静态函数或静态成员变量）、后普通（非静态函数或非静态成员变量）”的方式来排列的


成员变量之间或函数之间，还会按照作用域范围从大到小的顺序来排列，先写 public成员变量或函数，然后是 protected 的，最后是 private 的。

#### 关于编码技巧

13将复杂的逻辑提炼拆分成函数和类

14通过拆分成多个函数或将参数封装为对象的方式，来处理参数过多的情况

15函数中不要使用参数来做代码执行逻辑的控制

16函数设计要职责单一

17移除过深的嵌套层次，方法包括：去掉多余的 if 或 else 语句，使用 continue、
break、return 关键字提前退出嵌套，调整执行顺序来减少嵌套，将部分嵌套逻辑抽象成函数

18用字面常量取代魔法数

19用解释性变量来解释复杂表达式，以此提高代码可读性

20团队或项目要制定统一的编码规范codereview督促执行



升级重构有两种常见的形式，一种是纯代码式的升级，另外一种是包含存储和代码的升级

包含存储和代码的重构升级是指在上述纯代码之外，将原有架构里的存储也一起升级。

存储升级有两种形式

第一种是将存储类型进行升级，比如将数据库升级为缓存，将原有的读接口从数据库切换至缓存

第二种是将一个表结构的存储升级为同类型存储的另外一个更加合理的表结构

纯代码重构的切换

​	通过灰度的方式，既可以做到纯代码的升级重构切换，又可以缩小因此可能带来的线上问题的影响范围

含存储重构的切换

​	含存储的重构切换有一个重要步骤便是数据迁移

​	对于含存储重构的切换，最简单的方法便是停服

​	切换架构

​		首先进行数据同步，在完成数据同步之后，便可以进行用户的灰度切量了，将用户逐步切换至升级重构的新版本

​       增量同步、全量同步、数据对比验证、

​	   用户切换

​			1、对于升级重构的系统涉及的所有用户进行分析并按等级划分，如果重构的模块是订单模块，可以将用户按历史以来的下单量、订单金额进行排序，订单量小、下单金额低的用户排在最前面

​			2、对上述用户进行数据分析，分析这些用户里哪些用户使用了较多的系统功能，使用功能较多的用户排序在前面。在切量时，使用系统功能最多的用户会优先进行切量

系统架构大体上类似，其中只有个别模块存在差异，但各个研发团队还是从零开始建设全部模块的方式，称为烟囱式架构

平台化是知识将重复模块进行融合，从降低技术重复的角度出发，从而提升效率

而中台化是在平台化之后，从业务复用的角度出发，进一步提升业务需求的效率

业务能力可视化：将业务逻辑可以直接在可视化平台上展现出来，业务方和产品经理不需要和研发来回沟通上周的时间来确认需求，可以极大地降低沟通时间，提升效率

业务能力配置化：上述可视化的业务流程中，有些节点时实心圆圈，有些是空心的圆圈。空心表示代码执行到此流程节点时会直接跳过，而实心表示会执行此流程节点。流程节点是为空心还是实心，是可配置的，此配置功能可以落地在上述介绍的可视化平台里



















# 如何做代码审查

## 审查时机

及时评审

提升评审的频率，比如，每天评审一次

周期过长，累积的问题就会增多，造成的结果就是太多问题让人产生无力感

## 常规checklist

目录设置是否合理、模块划分是否清晰、代码结构是否满足“高内聚、松耦合”？
是否遵循经典的设计原则和设计思想（SOLID、DRY、KISS、YAGNI、LOD 等）？
设计模式是否应用得当？是否有过度设计？
代码是否容易扩展？如果要添加新功能，是否容易实现？
代码是否可以复用？是否可以复用已有的项目代码或类库？是否有重复造轮子？
代码是否容易测试？单元测试是否全面覆盖了各种正常和异常的情况？
代码是否易读？是否符合编码规范（比如命名和注释是否恰当、代码风格是否一致等）？

## 业务需求checklist

代码是否实现了预期的业务需求？
逻辑是否正确？是否处理了各种异常情况？异常考虑是否全面？
日志打印是否得当？是否方便 debug 排查问题？
接口是否易用？是否支持幂等、事务等？
代码是否存在并发问题？是否线程安全？
性能是否有优化空间，比如，SQL、算法是否可以优化？
是否有安全漏洞？比如输入输出校验是否全面？
性能是否满足业务需求？

# 如何实现可测试性

## 什么是单元测试？

单元测试是代码层面的测试，用于测试“自己”编写的代码的逻辑正确性。

单元测试顾名思义是测试一个“单元”，这个“单元”一般是类或函数，而不是模块或者系统

## 为什么要写单元测试？

单元测试能有效地发现代码中的 Bug、代码设计上的问题。

写单元测试的过程本身就是代码重构的过程。

## 如何编写单元测试？

写单元测试就是针对代码设计覆盖各种输入、异常、边界条件的测试用例，并将其翻译成代码的过程

1、 什么是代码的可测试性？

所谓代码的可测试性，就是针对代码编写单元测试的难易程度

对于一段代码，如果很难为其编写单元测试，或者单元测试写起来很费劲，需要依靠单元测试框架中很高级的特性，那往往就意味着代码设计得不够合理，代码的可测试性不好

2、编写可测试性代码的最有效手段

依赖注入是编写可测试性代码的最有效手段

通过依赖注入，我们在编写单元测试的时候，可以通过 mock 的方法解依赖外部服务

除了 mock 方式，我们还可以利用二次封装来解决某些代码行为不可控的情况

3、常见的 Anti-Patterns

常见的测试不友好的代码有下面这 5 种

代码中包含未决行为逻辑

所谓的未决行为逻辑就是，代码的输出是随机或者说不确定的，比如，跟时间、随机数有关的代码滥用

可变全局变量

全局变量是一种面向过程的编程风格，有种种弊端。实际上，滥用全局变量也让编写单元测试变得困难

滥用静态方法

静态方法跟全局变量一样，也是一种面向过程的编程思维。

在代码中调用静态方法，有时候会导致代码不易测试。主要原因是静态方法也很难 mock

只有在这个静态方法执行耗时太长、依赖外部资源、逻辑复杂、行为未决等情况下，我们才需要在单元测试中 mock 这个静态方法

如果只是类似Math.abs() 这样的简单静态方法，并不会影响代码的可测试性，因为本身并不需要mock

使用复杂的继承关系

相比组合关系，继承关系的代码结构更加耦合、不灵活，更加不易扩展、不易维护。实际上，继承关系也更加难测试

高度耦合的代码

如果一个类职责很重，需要依赖十几个外部对象才能完成工作，代码高度耦合，那我们在编写单元测试的时候，可能需要 mock 这十几个依赖的对象



# 如何编写高质量代码

## 质量评价标准有哪些?

1、可维护性

2、可读性

​	要看代码是否符合编码规范、命名是否达意、注释是否详尽、函数是否长短合适、模
块划分是否清晰、是否符合高内聚低耦合等等；code review 是一个很好的测验代码可读性的手段

3、可扩展性

​	表示我们的代码应对未来需求变化的能力；代码的可扩展性表示，我们在不修改或少量修改原有代码的情况下，通过扩展的方式添加新的功能代码

 4、简洁性

​	尽量保持代码简单。代码简单、逻辑清晰，也就意味着易读、易维护

5、可复用性

​	尽量减少重复代码的编写，复用已有的代码

6、可测试性

​	代码可测试性的好坏，能从侧面上非常准确地反应代码质量的好坏。代码的可
测试性差，比较难写单元测试，那基本上就能说明代码设计得有问题

## 如何才能写出高质量的代码

面向对象中的继承、多态能让我们写出可复用的代码

设计原则中的单一职责、DRY、基于接口而非实现、里式替换原则等，可以让我们写出可复用、灵活、可读性好、易扩展、易维护的代码

编码规范能让我们写出可读性好的代码

设计模式可以让我们写出易扩展的代码

持续重构可以时刻保持代码的可维护性等等

如何保证质量

1、代码开发

单元测试、代码review、静态代码扫描

2、测试保障

功能测试、性能测试、高可用测试、稳定性测试

3、线上质量

灰度发布、紧急回滚、故障演练、线上监控和巡检



# 设计原则与思想

## 	单一职责原则

不要存在多于一个导致类变更的原因， 一个类只负责唯一职责。

不要设计大而全的类，要设计粒度小、功能单一的类。

如果一个类包含了两个或者两个以上业务不相干的功能，那我们就说它职责不够单一，应该将它拆分成多个功能更加单一、粒度更细的类

哪些情况就有可能说明类的设计不满足单一职责原则？

类中的代码行数、函数或者属性过多
类依赖的其他类过多，或者依赖类的其他类过多
私有方法过多
比较难给类起一个合适的名字
类中大量的方法都是集中操作类中的某几个属性

## 	里氏替换原则

​		在任何父类出现的地方可以用它的子类来替代。里式替换原则是用来指导，继承关系中子类该如何设计的一个原则。

​		里式替换原则，最核心的就是“design by contract，按照协议来设计”这几个字。父类定义了函数的“约定”（或者叫协议），那子类可以改变函数的内部实现逻辑，但不能改变函数原有的“约定”。这里的约定包括：函数声明要实现的功能；对输入、输出、异常的约定

## 	依赖倒置原则

​		 要依赖于抽象和接口，不要依赖于具体实现

## 	接口隔离原则

​		调用者不应该强迫依赖它不需要的接口

​		在设计接口时，不要设计出庞大膝肿的接口，因为实现这种接口时需要实现很多不必要的方法。

​		尽量设计出功能单一的接口，这样也能保证实现类的职责单一

## 	迪米特法则

也称最少知识原则，一个对象应该对其他对象保持最少的了解。简单来说，就是要求我们减低类间耦合

​	不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口

## 	 开放－封闭原则

​		程序要对扩展开放，对修改关闭。简单来说，当需求发生变化时，我们可以通过添加新的模块满足新需求，而不是通过修改原来的实现代码来满足新需求

## 组合原则

在软件复用时，要尽量先使用组合原则来实现，其次才考虑使用继承关系来实现

采用组合原则时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能

## DRY 原则

Don’t Repeat Yourself

不要写重复的代码，重复包括实现逻辑重复、功能语义重复和代码执行重复。

## KISS 原则

尽量保持简单

如何写出满足 KISS 原则的代码？

不要使用同事可能不懂的技术来实现代码

不要重复造轮子，要善于使用已经有的工具类库

## YAGNI 原则

英文全称是：You Ain’t Gonna Need It。	直译就是：你不会需要它。这条原则的核心思想就是：不要做过度设计

**用设计原则来评判代码设计哪里有问题，然后再通过具体的设计模式来改善**



重构作为保持代码质量不腐化的有效手段，利用的就是面向对象、设计原则、设计模式、编码规范这些理论。在重构的过程中，我们用代码质量评判标准来评判代码的整体质量，然后对照设计原则来发现代码存在的具体问题，最后用设计模式或者编码规范对存在的问题进行改善。



编程规范主要解决代码的可读性问题。我个人觉得，在编写代码的时候，我们要把可读性放到首位。只有在代码可读性比较好的情况下，我们再去考虑代码的扩展性、灵活性等。



评判代码质量的标准，比如可读性、可维护性、可扩展性、复用性等，这是从代码整体质量的角度来评判的但是，落实到具体的细节，我们往往从是否符合设计原则，来对代码设计进行评判。比如，我们说这段代码的可扩展性比较差，主要原因是违背了开闭原则。

面向对象的四大特性：封装、抽象、继承、多态

在平时的面向对象编程开发中，我们要避免编写出面向过程风格的代码

面向对象分析（OOA）、设计（OOD）、编程（OOP）

面向对象分析就是需求分析，面向对象设计是代码层面的设计，输出的设计结果是类。面向对象编程就是将设计的结果翻译成代码的过程。

面向对象设计分为四个环节：划分职责并识别出有哪些类、定义类及其属性和方法、定义类之间的交互关系、组装类并提供执行入口



面向对象编程，谨记基于接口而非实现的设计思想、多用组合少用继承的设计思想。



设计模式是针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或者设计思路。我们用设计原则来评判代码设计哪里有问题，然后再通过具体的设计模式来改善

经典的设计模式有 23 种，分三种类型：创建型、结构型和行为型。

创建型设计模式主要解决“对象的创建”问题，常用的有单例、工厂、建造者

结构型设计模式主要解决“类或对象的组合”问题，常用的代理、装饰者、适配器、门面

行为型设计模式主要解决“类或对象之间的交互”问题，常用的观察者、模板、策略、职责链、迭代器



# 设计模式

面向对象编程是一种编程范式或编程风格。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石 

面向对象分析就是要搞清楚做什么

面向对象设计就是要搞清楚怎么做

两个阶段最终的产出是类的设计，包括程序被拆解为哪些类，每个类有哪些属性方法、类与类之间如何交互等等

封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式（或者叫函数）来访问内部信息或者数据

抽象讲的是如何隐藏方法的具体实现，让调用者只需要关心方法提供了哪些功能，并不需要知道这些功能是如何实现的。

抽象作为一种只关注功能点不关注实现的设计思路

定义类的方法的时候，也要有抽象思维，不要在方法定义中，暴露太多的实现细节

继承是用来表示类之间的is-a 关系,继承最大的一个好处就是代码复用,但是过度使用继承，继承层次过深过复杂，就会导致代码可读性、可维护性变差。多用组合少用继承

多态是指，子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现，多态特性能提高代码的可扩展性和复用性、

抽象类具有哪些特性

抽象类不允许被实例化，只能被继承

抽象类可以包含属性和方法

子类继承抽象类，必须实现抽象类中的所有抽象方法

接口都有哪些特性

接口不能包含属性
接口只能声明方法，方法不能包含代码实现
类实现接口的时候，必须实现接口中声明的所有方法

抽象类既然属于类，也表示一种 is-a 的关系。相对于抽象类的 is-a 关系来说，接口表示一种 has-a 关系，表示具有某些功能。对于接口，有一个更加形象的叫法，那就是协议（contract）

抽象类更多的是为了代码复用，而接口就更侧重于解耦。接口是对行为的一种抽象，相当于一组协议或者契约。解决解耦问题，隔离接口和具体的实现，提高代码的扩展性。

 如何理解“高内聚、松耦合”？

高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一类中

松耦合指的是，在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动也不会或者很少导致依赖类的代码改动

# 如何应用设计思想模式原则？

拿到功能需求的时候，先去思考一下如何设计，而不是上来就写代码。

写代码时，我们也要时刻思考代码是否遵循了经典的设计思想、设计原则，比如是否足够可扩展、是否满足 SOLID 原则、可读性如何等等

写完代码之后，我们再思考一下，代码是否有进一步优化的空间。

Code Review 的时候，看到别人的优秀的代码，我们就去思考一下，有哪些值得借鉴的地方

在平时的开发中，我们要刻意的去做这种跟代码质量、代码设计相关的思考训练

# 如何使代码审查更高效?

设计

如何让新代码与全局的架构保持一致？

• 代码是否遵循SOLID原则，是否遵循团队使用的设计规范，如领域
驱动开发等？
• 新代码使用了什么设计模式？这样使用是否合适？
• 基础代码是否有结合使用了一些标准或设计样式，新的代码是否遵
循当前的规范？代码是否正确迁移，或参照了因不规范而淘汰的旧
代码？
• 代码的位置是否正确？比如涉及订单的新代码是否在订单服务相关
的位置？
• 新代码是否重用了现存的代码？新代码是否可以被现有代码重用？
新代码是否有重复代码？如果是的话，是否应该重构成一个更可被
重用的模式，还是当前还可以接受？
• 新代码是否被过度设计了？是否引入现在还不需要的重用设计？团
队如何平衡可重用和YAGNI(You Ain’t Gonna Need It)这两种观

可读性和可维护性

​	字段、变量、参数、方法、类的命名是否真实反映它们所代表的事物

​	我是否可以通过读代码理解他做了什么

​	我是否理解测试用例测了什么？
​	 测试是否很好地覆盖了用例的各种情况？它们是否覆盖了正常和异
常用例？是否有忽略的情况？
​	 错误信息是否可被理解？
​	不清晰的代码是否被文档、注释或容易理解的测试用例所覆盖？

功能

​	代码是否真的达到了预期的目标？

​	如果有自动化测试来确保代码的正确性，测试的代码是否真的可以验证代码达到了协定的需求？
​	代码看上去是否包含不明显的bug，比如使用错误的变量进行检查，或误把and写成or？

你是否考虑过

​	是否需要满足相关监管需求？

​	作者是否需要创建公共文档或修改现存的帮助文档？

​	是否检查了面向用户的信息的正确性？

​	是否有会在生产环境中导致应用停止运行的明显错误？代码是否会错误地指向测试数据库，是否存在应在真实服务中移除的硬编码的stub代码？

​	你对性能的需求是什么，你是否考虑了安全问题？

性能

​	这段代码是否有硬性的性能需求？

​	接受审查的代码是否涉及之前发布的服务等级协议（SLA）？或这个需求本身有特别的性能需求？

​	这个修复或新增的功能是否会反向影响到任何现存的性能测试结果

​	调用外部的服务或应用的代价是昂贵的：调用数据库、不必要的网络调用、移动或可穿戴应用过于频繁地调用后端程序

有效且高效地使用资源

​	代码是否用锁来控制共享资源的访问？这是否会导致性能降低或死锁？

​	是否存在内存泄露？Java中一些常见的原因会是：可变的静态字段，使用ThreadLocal变量和使用类加载器

​	是否存在无限增长？

​	是否正确关闭了资源？

​	资源池的配置是否正确？

审查者可以轻松找出的警告信号

​	反射：Java的反射比正常调用要慢。如果你在审查含有反射的代码，你就要问下是否必须使用它

​	超时：想一下“如果超时了，会对系统其他部分造成什么影响？”

​	并行：代码是否使用多线程来运行一个简单的操作？这样是否花费了更多的时间以及复杂度而并没有提升性能？

正确性

​	代码是否使用了正确的适合多线程的数据结构。

​	代码是否存在竞态条件（race conditions）？多线程环境中代码非常容易造成不明显的竞态条件。作为审查者，可以查看不是原子操作的get和set。
​	代码是否正确使用锁？和竞态条件相关，作为审查者你应该检查被审代码是否允许多个线程修改变量导致程序崩溃。代码可能需要同步、锁、原子变量来对代码块进行控制。
​	代码的性能测试是否有价值？很容易将小型的性能测试代码写得很糟糕，或者使用不能代表生产环境数据的测试数据，这样只会得到错误的结果。

​	缓存：缓存：虽然缓存是一种能防止过多高消耗请求的方式，但其本身也存在一些挑战。如果审查的代码使用了缓存，你应该关注一些常见的问题，如，不正确的缓存失效方式

代码级优化

​	代码是否在不要的地方使用同步或锁操作？如果代码始终运行在单线程中，锁往往是不必要的。
​	代码是否可以使用原子变量替代锁或同步操作？
​	代码是否使用了不必要的线程安全的数据结构？比如是否可以使用ArrayList替代Vector？
​	代码是否在通用的操作中使用了低性能的数据结构？如在经常需要查找某个特定元素的地方使用链表。
​	代码是否可以使用懒加载并从中获得性能提升？
​	条件判断语句或其他逻辑是否可以将最高效的求值语句放在前面来使其他语句短路？
​	代码是否存在许多字符串格式化？是否有方法可以使之更高效？
​	日志语句是否使用了字符串格式化？是否先使用条件判断语句校验了日志等级，或使用延迟求值？

简单的代码即高效的代码

​	短小的方法和类。

​	简单的逻辑，即消除嵌套的条件或循环语句。

安全

​	密码保护、数据保护、认证